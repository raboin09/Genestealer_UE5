// Fill out your copyright notice in the Description page of Project Settings.


#include "Characters/Animation/BaseAnimInstance.h"

#include "GameFramework/CharacterMovementComponent.h"
#include "Kismet/GameplayStatics.h"
#include "Kismet/KismetMathLibrary.h"

UBaseAnimInstance::UBaseAnimInstance()
{
	bPlayerUsingStrafingMovement = true;
}

void UBaseAnimInstance::NativeInitializeAnimation()
{
	Super::NativeInitializeAnimation();
	CharacterRef = Cast<ABaseCharacter>(TryGetPawnOwner());
	if(!CharacterRef)
	{
		return;
	}
	
	CharacterMovementComponentRef = CharacterRef->GetCharacterMovement();
	if(!CharacterMovementComponentRef)
	{
		return;
	}
	
	InitialRotationRate = CharacterMovementComponentRef->RotationRate.Yaw;
	InitialMaxAcceleration = CharacterMovementComponentRef->GetMaxAcceleration();
	InitialSprintMaxSpeed = CharacterRef->SprintSpeed;
	InitialRunMaxSpeed = CharacterRef->JogMaxSpeed;	
}

void UBaseAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
{
	Super::NativeUpdateAnimation(DeltaSeconds);
	if(!CharacterRef || !CharacterMovementComponentRef)
	{
		return;
	}
	
	Time = DeltaSeconds;
	if(const UCharacterMovementComponent* CharacterMovementComponent = CharacterRef->GetCharacterMovement())
	{
		bIsInAir = CharacterMovementComponent->IsFalling();
	}
	MovementVelocity = CharacterRef->GetVelocity().Length();
	CharacterLocation = CharacterRef->GetActorLocation();
	// TODO get AimingPose curve and input as Alpha (from TPSKit BP_PlayerCharacterBase::Calculate Aim Offset Angle)
	PlayerAimYawUnclamped = CharacterRef->CalculateAimOffsetYaw(PlayerAimYawUnclamped, 0.f);
	PlayerAimPitch = CharacterRef->CalculateAimOffsetPitch(PlayerAimPitch);
	bCharacterOrientedToStrafingMovement = !CharacterMovementComponentRef->bOrientRotationToMovement;
	ControlRotationYaw = CharacterRef->GetControlRotation().Yaw;
	ActorWorldRotationYaw = CharacterRef->GetActorRotation().Yaw;
	DesiredLocalMovingDirection = CharacterRef->CalculateCurrentInputLocalAngle();
	MovementInputYawAngleWorldSpace = UKismetMathLibrary::Conv_VectorToRotator(CharacterRef->GetLastMovementInputVector()).Yaw;

	Internal_AccelerationUpdate();
	Internal_RotationRateUpdate();

	// if(bSprinting)
	// {
	// 	CharacterMovementComponentRef->bOrientRotationToMovement = true;
	// } else
	// {
	// 	CharacterMovementComponentRef->bOrientRotationToMovement = false;
	// }

	AnalogInputScale = CharacterMovementComponentRef->GetAnalogInputModifier();
	
	// TODO adjust -50% if walking
	CharacterRef->CalculateMovementInputScale(MoveForwardScale, MoveRightScale);
	if(CurrentAcceleration > 0)
	{
		CurrentLocalMovingAngle = CharacterRef->CalculateCurrentMovingLocalAngle(false);
		LastFrameLocalMovingAngle = CharacterRef->CalculateCurrentMovingLocalAngle(true);
	}

	bWalking = (CharacterMovementComponentRef->MovementMode == EMovementMode::MOVE_Walking) && !bCrouching;
	if(bWalking)
	{
		MoveForwardScale *= .5f;
		MoveRightScale *= .5f;
	}

	if(bUsingCover && !CharacterRef->bExitingCover)
	{
		bIsPlayerHoldingShotKey = CharacterRef->bFiring;
		bInCoverFacingRight = CharacterRef->bPlayerFacingRight;
		bIsInMirroredAiming = !bInCoverFacingRight;
		if(MoveRightScale > 0.f)
		{
			bInCoverMovingRight = true;
		} else if(MoveRightScale < 0.f)
		{
			bInCoverMovingRight = false;
		}
	} else
	{
		const float DirectionAngleDiff = DesiredLocalMovingDirection - CurrentLocalMovingAngle;
		const float JogLeanTarget = UKismetMathLibrary::InRange_FloatFloat(DirectionAngleDiff, -90.f, 90.f) ? DirectionAngleDiff : 0.f;
		JogLeaningDirection = UKismetMathLibrary::FInterpTo(JogLeaningDirection, JogLeanTarget, UGameplayStatics::GetWorldDeltaSeconds(this), 4.f);
	}

	if(CharacterRef->bPlayerFacingRight)
	{
		MovingSidewaysInput = CharacterRef->MovingSidewaysInput;
		MovingForwardInput = CharacterRef->MovingForwardInput;
	} else
	{
		MovingSidewaysInput = CharacterRef->MovingSidewaysInput * -1.f;
		MovingForwardInput = CharacterRef->MovingForwardInput * -1.f;
	}

	if(GetCurveValue("Rot(yaw)") > 0.f && ShouldTurnInPlace())
	{
		float InterpYaw = GetCurveValue("Rot(yaw)");
		FRotator ActorRot = CharacterRef->GetActorRotation();
		FRotator Target = FRotator(ActorRot.Pitch, InterpYaw, ActorRot.Roll);
		UKismetMathLibrary::RInterpTo(ActorRot, Target, DeltaSeconds, 4.f);
	}

	if(GetCurveValue("Speed") > 0.f)
	{
		CharacterMovementComponentRef->MaxAcceleration = GetCurveValue("Speed");
	} else
	{
		CharacterMovementComponentRef->MaxAcceleration = InitialMaxAcceleration;
	}
}

void UBaseAnimInstance::Internal_AccelerationUpdate()
{
	// TODO acceleration for non strafing movement in macro AccelerationUpdate in AnimBP
	CurrentAcceleration = CharacterMovementComponentRef->GetCurrentAcceleration().Size();
	CharacterMovementComponentRef->MaxAcceleration = InitialMaxAcceleration;
	CharacterMovementComponentRef->MaxAcceleration = InitialMaxAcceleration;
	CurrentAccelerationScale = UKismetMathLibrary::MapRangeClamped(CurrentAcceleration, 0.f, InitialMaxAcceleration, 0.f, 1.f);
}

void UBaseAnimInstance::Internal_RotationRateUpdate()
{

}

bool UBaseAnimInstance::AssertLocomotion_ToIdle(int32 MachineIndex, int32 StateIndex)
{
	return !HasAcceleration() && !HasInput() && !HasMovementVelocity();
}

bool UBaseAnimInstance::AssertLocomotion_FromIdle(int32 MachineIndex, int32 StateIndex)
{
	return HasAcceleration() || HasInput() || HasMovementVelocity();
}

bool UBaseAnimInstance::AssertLocomotion_ToJogStart(int32 MachineIndex, int32 StateIndex)
{
	return HasForwardMomentum();
}

bool UBaseAnimInstance::AssertLocomotion_FromJogStart(int32 MachineIndex, int32 StateIndex)
{
	return !HasAcceleration() && HasMovementVelocity(200.f);
}

bool UBaseAnimInstance::AssertLocomotion_ToJogStop(int32 MachineIndex, int32 StateIndex)
{
	return !HasAcceleration() && !HasInput(.7f) && IsMovementVelocityInRange(250.f, 310.f);
}

bool UBaseAnimInstance::AssertLocomotion_FromJogStop(int32 MachineIndex, int32 StateIndex)
{
	return !HasAcceleration() && GetRelevantAnimTimeRemainingFraction(MachineIndex, StateIndex) <= .8f; 
}

bool UBaseAnimInstance::AssertLocomotion_ToJogWalkLocomotion(int32 MachineIndex, int32 StateIndex)
{
	// HasMovementVelocity(50.f)
	return HasMovementVelocity(250.f) && HasInput() && HasAcceleration() && GetRelevantAnimTimeRemainingFraction(MachineIndex, StateIndex) <= .01f;
}

bool UBaseAnimInstance::AssertLocomotion_FromJogWalkLocomotion(int32 MachineIndex, int32 StateIndex)
{
	return !HasInput(.7f) && IsMovementVelocityInRange(0.f, 300.f) && !HasAcceleration();
}
